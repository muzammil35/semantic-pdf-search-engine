<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>PDF Viewer</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
        <style>
            canvas {
                position: absolute;
                top: 0;
                left: 0;
            }
            .textLayer {
                position: absolute;
                top: 0;
                left: 0;
                overflow: hidden;
                opacity: 0.2;
                line-height: 1.0;
            }
            .textLayer > span {
                color: transparent;
                position: absolute;
                white-space: pre;
                cursor: text;
                transform-origin: 0% 0%;
            }
            .textLayer .highlight {
                background-color: rgba(255, 255, 0, 0.6);
                border-radius: 2px;
            }
            .textLayer .highlight.selected {
                background-color: rgba(255, 153, 0, 0.8);
            }
            .page-wrapper {
                position: relative;
                margin-bottom: 20px;
                box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                background: white;
            }
            #pdf-container {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            #search-bar {
                position: sticky;
                top: 0;
                z-index: 100;
                background: white;
                padding: 1rem;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
        </style>
    </head>
    <body class="bg-gray-100">
        <div id="search-bar" class="container mx-auto">
            <div class="flex gap-2 items-center">
                <input 
                    type="text" 
                    id="search-input" 
                    placeholder="Search in PDF..." 
                    class="flex-1 border rounded px-3 py-2"
                />
                <button 
                    id="prev-match" 
                    class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 disabled:bg-gray-300"
                    disabled
                >
                    ← Previous
                </button>
                <button 
                    id="next-match" 
                    class="bg-blue-500 text-white px-3 py-2 rounded hover:bg-blue-600 disabled:bg-gray-300"
                    disabled
                >
                    Next →
                </button>
                <span id="match-counter" class="text-sm text-gray-600 min-w-[100px]"></span>
                <select id="zoom-select" class="border rounded px-2 py-1 text-sm">
                    <option value="0.5">50%</option>
                    <option value="0.75">75%</option>
                    <option value="1">100%</option>
                    <option value="1.5" selected>150%</option>
                    <option value="2">200%</option>
                    <option value="2.5">250%</option>
                    <option value="3">300%</option>
                </select>
            </div>
        </div>

        <div class="container mx-auto p-4">
            <div id="loading" class="text-center py-8">
                <div class="inline-block animate-spin rounded-full h-12 w-12 border-b-2 border-gray-900"></div>
                <p class="mt-4 text-gray-600">Loading PDF...</p>
            </div>
            
            <div id="pdf-container"></div>
        </div>

        <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfDoc = null;
        let currentScale = 1.5;
        const MAX_OUTPUT_SCALE = 2;
        const renderedPages = new Map();
        const renderTasks = new Map();
        const textLayers = new Map();

        let searchMatches = [];
        let currentMatchIndex = -1;

        const container = document.getElementById('pdf-container');
        const loading = document.getElementById('loading');
        const searchInput = document.getElementById('search-input');
        const prevButton = document.getElementById('prev-match');
        const nextButton = document.getElementById('next-match');
        const matchCounter = document.getElementById('match-counter');

        async function loadPDF() {
            const loadingTask = pdfjsLib.getDocument('/api/pdf');
            pdfDoc = await loadingTask.promise;
            loading.style.display = 'none';

            createPagePlaceholders();
            setupObserver();
        }

        function createPagePlaceholders() {
            for (let i = 1; i <= pdfDoc.numPages; i++) {
                const wrapper = document.createElement('div');
                wrapper.className = 'page-wrapper';
                wrapper.dataset.page = i;
                
                const canvas = document.createElement('canvas');
                canvas.dataset.page = i;
                
                const textLayerDiv = document.createElement('div');
                textLayerDiv.className = 'textLayer';
                textLayerDiv.dataset.page = i;
                
                wrapper.appendChild(canvas);
                wrapper.appendChild(textLayerDiv);
                container.appendChild(wrapper);
            }
        }

        function setupObserver() {
            const observer = new IntersectionObserver(
                entries => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            const pageNum = Number(entry.target.dataset.page);
                            renderPage(pageNum);
                        }
                    });
                },
                { rootMargin: '200px' }
            );

            document.querySelectorAll('.page-wrapper').forEach(w => observer.observe(w));
        }

        async function renderPage(pageNum) {
            if (renderedPages.get(pageNum) === currentScale) return;

            if (renderTasks.has(pageNum)) {
                renderTasks.get(pageNum).cancel();
            }

            const page = await pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: currentScale });

            const wrapper = document.querySelector(`.page-wrapper[data-page="${pageNum}"]`);
            const canvas = wrapper.querySelector('canvas');
            const textLayerDiv = wrapper.querySelector('.textLayer');

            const outputScale = Math.min(window.devicePixelRatio || 1, MAX_OUTPUT_SCALE);
            const ctx = canvas.getContext('2d');

            canvas.width = Math.floor(viewport.width * outputScale);
            canvas.height = Math.floor(viewport.height * outputScale);
            canvas.style.width = `${viewport.width}px`;
            canvas.style.height = `${viewport.height}px`;
            
            wrapper.style.width = `${viewport.width}px`;
            wrapper.style.height = `${viewport.height}px`;
            textLayerDiv.style.width = `${viewport.width}px`;
            textLayerDiv.style.height = `${viewport.height}px`;

            const renderTask = page.render({
                canvasContext: ctx,
                viewport,
                transform: outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : null
            });

            renderTasks.set(pageNum, renderTask);

            try {
                await renderTask.promise;
                renderedPages.set(pageNum, currentScale);
                
                // Render text layer
                await renderTextLayer(page, viewport, textLayerDiv, pageNum);
            } catch (e) {
                if (e?.name !== 'RenderingCancelledException') {
                    console.error(e);
                }
            }
        }

        async function renderTextLayer(page, viewport, textLayerDiv, pageNum) {
            const textContent = await page.getTextContent();
            textLayerDiv.innerHTML = '';
            
            const textDivs = [];
            let pageText = '';

            textContent.items.forEach((item, index) => {
                // Calculate correct position using viewport transformation
                const tx = viewport.transform;
                const angle = Math.atan2(item.transform[1], item.transform[0]);
                
                let fontSize = Math.sqrt(
                    item.transform[2] * item.transform[2] + 
                    item.transform[3] * item.transform[3]
                );
                
                const fontHeight = fontSize;
                fontSize = fontSize * viewport.scale;
                
                // Calculate position
                const left = item.transform[4] * viewport.scale + tx[4];
                const top = viewport.height - (item.transform[5] * viewport.scale + tx[5]) - fontHeight * viewport.scale;
                
                const span = document.createElement('span');
                span.textContent = item.str;
                span.style.left = `${left}px`;
                span.style.top = `${top}px`;
                span.style.fontSize = `${fontSize}px`;
                span.style.position = 'absolute';
                span.style.transformOrigin = '0% 0%';
                
                if (angle !== 0) {
                    span.style.transform = `rotate(${angle}rad)`;
                }
                
                // Get font family from styles
                const style = textContent.styles[item.fontName];
                if (style && style.fontFamily) {
                    span.style.fontFamily = style.fontFamily;
                }
                
                span.dataset.index = index;
                textLayerDiv.appendChild(span);
                textDivs.push(span);
                
                // Build full page text for searching
                pageText += item.str;
            });

            textLayers.set(pageNum, {
                textContent,
                textDivs,
                pageText
            });
            
            // Re-apply search highlights if there's an active search
            if (searchInput.value) {
                highlightSearchInPage(pageNum, searchInput.value);
            }
        }

        function highlightSearchInPage(pageNum, searchText) {
            const textLayer = textLayers.get(pageNum);
            if (!textLayer) return [];

            const matches = [];
            const searchLower = searchText.toLowerCase().trim();
            if (!searchLower) return matches;

            // Clear previous highlights
            textLayer.textDivs.forEach(span => {
                span.classList.remove('highlight', 'selected');
            });

            const pageTextLower = textLayer.pageText.toLowerCase();
            let searchIndex = 0;
            
            // Find all occurrences in the page text
            while ((searchIndex = pageTextLower.indexOf(searchLower, searchIndex)) !== -1) {
                const matchStart = searchIndex;
                const matchEnd = searchIndex + searchLower.length;
                
                // Find which text items contain this match
                let currentPos = 0;
                const affectedSpans = [];
                
                textLayer.textContent.items.forEach((item, index) => {
                    const itemStart = currentPos;
                    const itemEnd = currentPos + item.str.length;
                    
                    // Check if this item overlaps with the match
                    if (itemStart < matchEnd && itemEnd > matchStart) {
                        affectedSpans.push(textLayer.textDivs[index]);
                    }
                    
                    currentPos = itemEnd;
                });
                
                // Highlight all affected spans
                affectedSpans.forEach(span => {
                    span.classList.add('highlight');
                });
                
                // Store match info (use first span for scrolling)
                if (affectedSpans.length > 0) {
                    matches.push({
                        pageNum,
                        spans: affectedSpans,
                        mainSpan: affectedSpans[0]
                    });
                }
                
                searchIndex = matchEnd;
            }

            return matches;
        }

        function performSearch(searchText) {
            searchMatches = [];
            currentMatchIndex = -1;

            if (!searchText || !searchText.trim()) {
                clearHighlights();
                updateMatchCounter();
                return;
            }

            // Search in all rendered pages
            textLayers.forEach((_, pageNum) => {
                const pageMatches = highlightSearchInPage(pageNum, searchText);
                if (pageMatches) {
                    searchMatches.push(...pageMatches);
                }
            });

            updateMatchCounter();
            
            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                scrollToMatch(0);
            }
        }

        function clearHighlights() {
            textLayers.forEach(textLayer => {
                textLayer.textDivs.forEach(span => {
                    span.classList.remove('highlight', 'selected');
                });
            });
        }

        function scrollToMatch(index) {
            if (index < 0 || index >= searchMatches.length) return;

            // Remove 'selected' from previous match
            searchMatches.forEach(match => {
                match.spans.forEach(span => span.classList.remove('selected'));
            });

            // Add 'selected' to current match
            const match = searchMatches[index];
            match.spans.forEach(span => span.classList.add('selected'));
            
            // Scroll to the match
            match.mainSpan.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            currentMatchIndex = index;
            updateMatchCounter();
        }

        function updateMatchCounter() {
            const total = searchMatches.length;
            if (total === 0) {
                matchCounter.textContent = '';
                prevButton.disabled = true;
                nextButton.disabled = true;
            } else {
                matchCounter.textContent = `${currentMatchIndex + 1} / ${total}`;
                prevButton.disabled = false;
                nextButton.disabled = false;
            }
        }

        // Event listeners
        searchInput.addEventListener('input', (e) => {
            performSearch(e.target.value);
        });

        prevButton.addEventListener('click', () => {
            if (searchMatches.length === 0) return;
            const newIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length;
            scrollToMatch(newIndex);
        });

        nextButton.addEventListener('click', () => {
            if (searchMatches.length === 0) return;
            const newIndex = (currentMatchIndex + 1) % searchMatches.length;
            scrollToMatch(newIndex);
        });

        // Keyboard shortcuts
        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    prevButton.click();
                } else {
                    nextButton.click();
                }
            }
        });

        document.getElementById('zoom-select').addEventListener('change', e => {
            currentScale = Math.min(parseFloat(e.target.value), 2);
            renderedPages.clear();
            textLayers.clear();

            renderTasks.forEach(task => task.cancel());
            renderTasks.clear();

            document.querySelectorAll('.page-wrapper').forEach(wrapper => {
                const rect = wrapper.getBoundingClientRect();
                if (rect.top < window.innerHeight + 200 && rect.bottom > -200) {
                    renderPage(Number(wrapper.dataset.page));
                }
            });
        });

        loadPDF();
        </script>

    </body>
    </html>